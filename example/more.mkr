# simple example in Makar

# [] subscript operator
# {} set operator
# || cardinality/magnitude operator
# $ series annotation
# & set annotation

# an infinite set
N0 = N + {0}

# an infinite set
circle = { c in C : |c| = 1 }

# an infinite series
factorial[ n in N0 ] =
  | 1 if n = 0 or n = 1
  | n * factorial[ n - 1 ] otherwise

main( a in ( N + {0} ) ) = factorial[ a ]

# an infinite series
fib[ n in N ] =
  | 1 if n = 1 or n = 2
  | fib[ n - 1 ] + fib[ n - 2 ] otherwise

# a finite set is unordered
first100Fibs = { fib[ n ] : n in 1..100  }

# a finite series is a tuple
first100FibsOrdered = ( fib[ n ] : n in 1..100  )


# function of an infinite series
bounded( $s ) =
  | false if lim[ n -> infinity ]( s[ n ] ) = undefined
  | true otherwise

:isFibBounded = bounded( fib )

# define an operator
`^`(x in Rplus, y in Rplus) = exp( y * ln(x) )

# an infinite series of functions
mandelZ[ n in N ]( c in C ) =
  | 0 if n = 1
  | mandelZ[ n - 1 ]^2 + c otherwise

# an infinite set
mandelbrot = {
  c in C : bounded( |mandelZ(c)| )
}

cgrid( h in R ) = {
  c in C :
    Re( c ) / h in N and
    Im( c ) / h in N
}

mandelData[ n in N ]( h in R, r in R ) = {
  ( c, |mandelZ[n](c)| ) : c in cgrid( h ) and |c| < r
}

# an output symbol
:mandelplot = mandelData[10](0.01, 2)

# i.e. we want to find
evalPoints = { c :
  sqrt( a^2 + b^2 ) < 2 where
  c = a + b*i ,
  a in 0.01 * N ,
  b in 0.01 * N
}



`-`( &X, &Y ) = { z : z in X and z not in Y }

`#..#` = n in Natural, m in Natural -> { z in Natural : z >= n and z <= m }

`]#,#]` = ( x, y ) in Real -> { z in Real : z > x and z <= y }

]50,100]

mySum = lim_[ n -> infinity ]( sum_{x in [n]}( 1 / x^2 ) )

sum_X = f ->
  | f(x_1) if |X| = 1
  | f(x_1) + sum_{ y in (X - x_1) }( f(y) ) otherwise

mean = X ->
  sum_{ i in 1..n }( x_i ) / n where
  n = |X|

quantile = X, p in [0,1[ -> m :
  |Less| <= n * p and
  |More| <= n * p where
  n = |X|,
  x in Less if x < m,
  x in More if x > m

median = X ->
  quantile( X, 0.5 )

lowerQuartile = X ->
  quantile( X, 0.25 )

upperQuartile = X ->
  quantile( X, 0.75 )

iqr = X ->
  upperQuartile(X) - lowerQuartile(X)

outliers( &X ) = { x in X :
  ( x > upperQuartile(X) and x - upperQuartile(X) > 1.5 * iqr(X) ) or
  ( x < lowerQuartile(X) and lowerQuartile(X) - x > 1.5 * iqr(X) )
}

argmax[&S](f) =  x in S :
  f(s) <= f(x),
  s in S


#sqrt( x in Rplus ) = s in Rplus : s^2 = x
sqrt(x in R) =
  | 0 if x = 0
  | %sqrt(x) if x in Rplus
  | sqrt(|x|) * i otherwise

mode( &X ) =
  argmax[ y in X ](| S[y] |) where
  x in S[y] if x = y,
  x in X

t( X1, X2 : |X1| = |X2| ) =
  ( mean(X1) - mean(X2) )/( sp * sqrt(2/n) ) where
  sp = sqrt( ( var(X1) + var(X2) )/2 ),
  n = |X1|

First10 = (1..10)^2

Rplus = { x in R : x > 0 }

Evens = { n : ( exists k in Naturals : 2*k = n ) }

Coords = { ( k, x ) : k in Blah and x in Xxx and p(x) }

clean( &X ) = X - outliers(X)
Data: read("iris.csv")_"sepal width"
CleanedData: clean(Data)

:myPlot = plot( CleanedData )
