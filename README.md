# antlr4nim
 Nim interface to ANTLR4 listener/visitor via jsffi

## Who is this for?
You have an idea for an amazing new DSL that you're itching to implement.

You know that the [ANTLR4](https://www.antlr.org/) parser generator makes it possible to 

* specify your language formally as a grammar.
* autogenerate a lexer and parser for that grammar in several target languages.
* repeat the process as much as you like, knowing that any changes you make to the grammar are dealt with seamlessly.



You also know that [Nim](https://nim-lang.org/) is an expressive general-purpose language that

* compiles to efficient C, C++ or JavaScript code.
* has powerful metaprogramming tools that will make it much easier to write a compiler for your new language.

You want to use both together? Of course you do. But ANTLR4 has no Nim target :(

Fortunately, Nim has good interops with JavaScript. **antlr4nim** is a module to support an ANTLR4/Nim workflow, using Nim's [JavaScript FFI](https://nim-lang.org/docs/jsffi.html). 

*A similar approach should be possible for the C++ ANTLR4 target, but unfortuately [c2nim](https://github.com/nim-lang/c2nim) doesn't like the header files that ANTLR4 generates. My C++ experience is zero so I would be very happy to receive a PR on this issue :)*

## How does it work?
Parsing is executed on the JavaScript side, using the default listener/visitor code that ANTLR4 generates for you. You override the default behaviour with custom methods in Nim that will be bound to your listener/visitor object.
A basic JavaScript entry point is provided, which you can modify to your own needs.

The `antlr` macro generates the proc that performs the bindings. 

The macros `visit`, `enter` and `exit` and the proc `txt` help to reduce boilerplate in your Nim code. 


## Instructions
(commands in parentheses are how I do each step on MacOS)

### You will need
* Nim (`brew install nim`)
* Node.js (`brew install node`)
* ANTLR4 tool (`brew install antlr@4`)
* The ANTLR4 JavaScript runtime (`npm install antlr4`)
* Your grammar as a .g4 file

For the example, I will use the [CSV grammar](https://github.com/antlr/grammars-v4/tree/master/csv) from the ANTLR repo.
(`wget https://raw.githubusercontent.com/antlr/grammars-v4/master/csv/CSV.g4`)

### Build the JS target from your grammar
For the purposes of the example, we will build both the visitor and the listener. Probably you only want one of them.

```
antlr -Dlanguage=JavaScript -visitor -listener CSV.g4
```
The following files (and others) will be created:

* `CSVLexer.js`
* `CSVParser.js`
* `CSVListener.js`
* `CSVVisitor.js`

### Clone the antlr4nim package
```
nimble develop antlr4nim
```

### Initialise the project
```
nimble init CSV {listener|visitor}
```
Running the `init` task creates the following files:

* `CSVLexer.mjs`  (a copy of `CSVLexer.js`)
* `CSVParser.mjs` (a copy of `CSVParser.js`, edited to import the .mjs files)

( with the `listener` option: )

* `CSVListener.mjs` (a copy of `CSVListener.js`)
* `myCSVListener.nim` (an empty Nim listener)
* `runMyCSVListener.mjs` (the JS entry point to the listener)

( with the `visitor` option: )

* `CSVVisitor.mjs` (a copy of `CSVVisitor.js`)
* `myCSVVisitor.nim` (an empty Nim visitor)
* `runMyCSVVisitor.mjs` (the JS entry point to the visitor)

The .mjs files are needed for Node.js to import everything correctly. 

`nimble init` won't clobber any files that already exist, so you will need to remove them if you want to start again.

### Edit your Nim code
The generated Nim file contains the macro skeleton to work from.

`myCSVListener.nim`:

```{nim}
import antlr4nim, jsffi

antlr:
  enter:
  	# insert enter procs here
  	discard
  exit:
	# insert exit procs here
	discard

```

`myCSVVisitor.nim`:

```{nim}
import antlr4nim, jsffi

antlr:
  visit:
  	# insert visit procs here
  	discard

```
Insert procs within the macro blocks to associate them with the parsing events *enter*, *exit* or *visit* for the specified parse tree nodes. See below for simple examples of a listener and a visitor pattern.

The ANTLR4 context object will be passed to your proc as `ctx`, and you have access to its methods and properties in the same way as you would have on the JS side. All JS objects have type `JsObject` so need conversions before they can be used in Nim.





### Compile and run
```
nim js myCSV{Listener|Visitor}.nim
```
compiles your code to `myCSV{Listener|Visitor}.js`, then

```
node runMyCSV{Listener|Visitor}.mjs <filename> <startNode>
```
will run it.

The autogenerated JS entry point contains everything needed for a basic use case. You just need to specify the source filename and the starting parse tree node.

## Listener Example
We will make a listener to convert a CSV file to a Markdown table.

Here's our example input:

```
"REVIEW_DATE","AUTHOR","ISBN","DISCOUNTED_PRICE"
"1985/01/21","Douglas Adams",0345391802,5.95
"1990/01/12","Douglas Hofstadter",0465026567,9.95
"1998/07/15","Timothy ""The Parser"" Campbell",0968411304,18.99
"1999/12/03","Richard Friedman",0060630353,5.95
"2001/09/19","Karen Armstrong",0345384563,9.95
"2002/06/23","David Jones",0198504691,9.95
"2002/06/23","Julian Jaynes",0618057072,12.50
"2003/09/30","Scott Adams",0740721909,4.95
"2004/10/04","Benjamin Radcliff",0804818088,4.95
"2004/10/04","Randel Helms",0879755725,4.50
```

Here is `CSV.g4`:

```{g4}
grammar CSV;

csvFile: hdr row+ ;
hdr : row ;

row : field (',' field)* '\r'? '\n' ;

field
    : TEXT
    | STRING
    |
    ;

TEXT   : ~[,\n\r"]+ ;
STRING : '"' ('""'|~'"')* '"' ; // quote-quote is an escaped quote
```

Here is my edited `myCSVListener.nim`:

```{nim}
import antlr4nim, jsffi, strutils

var width = 0
var finishedHeader = false

var output = ""

proc doOutput =
  echo output

antlr:
  enter:
    proc row =
      output &= "|"                         # each row starts with |
  exit:
    proc csvFile =
      doOutput()                            # finished! call output proc
    proc hdr =
      finishedHeader = true
      output &= "|"                         # start the header divider
      for i in 1..width: output &= "---|"   # complete the header divider
      output &= "\n"                        # newline
    proc row =
      output &= '\n'                        # newline on finishing row
    proc field =
      if( ctx.STRING() != nil ):            # if the rule matched a STRING:
        var x = ctx.txt
        x = x[ 1 .. ^2 ]                    #   removes outside " "
        x = x.replace("\"\"","\"")          #   replaces "" with "
        output &= x & "|"                   #   cell content + |
      else:                                 # otherwise:
        output &= ctx.txt & "|"             #   cell content + |
      if not finishedHeader: width += 1     # count the columns

```
The procs for parse tree nodes need to be named with the identifiers taken from the .g4 file. It's fine to have both an *enter* and an *exit* proc with the same name: the macros are going to rename everything.

The proc `txt` provides a shorthand for the text content of a node, as a Nim string. `x.txt` means `$(x.getText().to(cstring))`.

Note that the Nim listener is responsible for creating its own output. It won't be able to return anything to the JS side.

When I run `nim js myCSVListener.nim`, the macros convert it to

```
proc bindMethods( this: JsObject ) =
  when declared( bindEnterMethods ):
    bindEnterMethods( this )
  when declared( bindExitMethods ):
    bindExitMethods( this )
  when declared( bindVisitMethods ):
    bindVisitMethods( this )

module.exports.bindMethods = bindMethods

proc enterRow(this: JsObject; ctx: JsObject): void =
  output &= "|"

proc bindEnterMethods(this: JsObject) =
  this.enterRow = bindMethod enterRow

proc exitCsvFile(this: JsObject; ctx: JsObject): void =
  doOutput()

proc exitHdr(this: JsObject; ctx: JsObject): void =
  finishedHeader = true
  output &= "|"
  for i in 1 .. width:
    output &= "---|"
  output &= "\n"

proc exitRow(this: JsObject; ctx: JsObject): void =
  output &= '\n'

proc exitField(this: JsObject; ctx: JsObject): void =
  if (ctx.STRING() != nil):
    var x = ctx.txt
    x = x[1 .. ^2]
    x = x.replace("\"\"", "\"")
    output &= x & "|"
  else:
    output &= ctx.txt & "|"
  if not finishedHeader:
    width += 1

proc bindExitMethods(this: JsObject) =
  this.exitCsvFile = bindMethod exitCsvFile
  this.exitHdr = bindMethod exitHdr
  this.exitRow = bindMethod exitRow
  this.exitField = bindMethod exitField

```
which is then compiled directly to JS and output as `myCSVListener.js`.

Notice that the generated `bindMethods` proc will be used to override the empty default JS listener methods with the ones defined in Nim.


Finally, we run the listener with `node runMyCSVListener.mjs example.csv csvFile` to produce

```
|REVIEW_DATE|AUTHOR|ISBN|DISCOUNTED_PRICE|
|---|---|---|---|
|1985/01/21|Douglas Adams|0345391802|5.95|
|1990/01/12|Douglas Hofstadter|0465026567|9.95|
|1998/07/15|Timothy "The Parser" Campbell|0968411304|18.99|
|1999/12/03|Richard Friedman|0060630353|5.95|
|2001/09/19|Karen Armstrong|0345384563|9.95|
|2002/06/23|David Jones|0198504691|9.95|
|2002/06/23|Julian Jaynes|0618057072|12.50|
|2003/09/30|Scott Adams|0740721909|4.95|
|2004/10/04|Benjamin Radcliff|0804818088|4.95|
|2004/10/04|Randel Helms|0879755725|4.50|
```
 which renders as
 
|REVIEW_DATE|AUTHOR|ISBN|DISCOUNTED_PRICE|
|---|---|---|---|
|1985/01/21|Douglas Adams|0345391802|5.95|
|1990/01/12|Douglas Hofstadter|0465026567|9.95|
|1998/07/15|Timothy "The Parser" Campbell|0968411304|18.99|
|1999/12/03|Richard Friedman|0060630353|5.95|
|2001/09/19|Karen Armstrong|0345384563|9.95|
|2002/06/23|David Jones|0198504691|9.95|
|2002/06/23|Julian Jaynes|0618057072|12.50|
|2003/09/30|Scott Adams|0740721909|4.95|
|2004/10/04|Benjamin Radcliff|0804818088|4.95|
|2004/10/04|Randel Helms|0879755725|4.50|

## Visitor Example
An ANTLR visitor is more complicated than a listener:

* The `visit` method can return something.
* The order of visits isn't fixed, but needs to be handled by the visitor.

Visitors can be useful to construct an AST from the parse tree, because the visitor can define a `visit` method for each different node type, which will construct and return the node's representation.

For our visitor example, we will construct a `Book` object for each row of the table.

Here is `myCSVVisitor.nim`:

```
## antlr4nim visitor example

import antlr4nim, jsffi, jsre, strutils, times, strformat, algorithm

var dateFormat = initTimeFormat("yyyy/MM/dd")
var moneyFormat = newRegExp(r"^\d+\.\d\d$", r"")

type Book = object
  author, isbn: string
  reviewDate: DateTime
  discountedPrice: float

var library = newSeq[Book](0)

proc addToLibrary( newBooks: seq[Book] ) =
  library &= newBooks
  echo "You added the following books to the library:"
  for b in newBooks.sortedByIt(it.isbn):
    echo &"{b.isbn} ({b.author})"

antlr:
  visit:
    proc csvFile =
      var books = newSeq[Book](0)
      for x in this.visitChildren(ctx):         # get the result from each child node
        if( x != nil ):                         # exclude any rows that return nil
          books &= x.to(Book)
      addToLibrary( books )
    proc hdr =
      return nil                                # the header row returns nil
    proc row =
      var b = Book(                             # construct a new Book object for this row
        author: $( this.visit(ctx.field(1)) ),  # get the result from a specific node
        isbn: $( this.visit(ctx.field(2)) ),
        reviewDate: parse( $( this.visit(ctx.field(0)) ), dateFormat ),
        discountedPrice: this.visit(ctx.field(3)).to(float)
      )
      return b.toJs                         # return the Book
    proc field =
      var x = ctx.txt
      if( ctx.STRING() != nil ):                                # if the node contains a STRING:
        x = x[ 1 .. ^2 ]                                        #   remove outside " "
        x = x.replace("\"\"","\"")                              #   replace "" with "
      elif( test( moneyFormat, ctx.getText().to(cstring) ) ):   # else if the node text is an amount:
          return parseFloat(x).toJs                             #   return a float
      return x.toJs                                             # return a string
```

The variable `this` refers to the visitor itself.
The variable `ctx` is the ANTLR context object, as in the listener example.

The *default* `visit` method provided by `CSVVisitor.mjs` for every node is `return( this.visitChildren(ctx) )`. 
If we override a `visit` method then we are responsible for calling any further nodes, using `this.visitChildren(ctx)` or `this.visit(childCtx)`.

We need to be careful with type handling, because all of the visit methods will return a `JsObject`.
Wrap a Nim object to a JsObject with `x.toJs`
Unwrap a JsObject with x.to(type)
Unwrap a JsObject to a cstring (i.e. a JS String) to use with a jsre regex, as in the example.
To unwrap a JsObject and convert to a string (i.e. a Nim String), use the shorthand $( x )

`this.visitChildren(ctx)` returns a collection wrapped as a single JsObject - you can iterate this directly or convert to a seq[JsObject] using `toSeq` from `sequtils`.

## Wait, I still don't understand!
There's a lot of bits and pieces here, but here's some further reading that might help:

### ANTLR4
* You can learn all the necessary parts of ANTLR4 from the [mega-tutorial](https://tomassetti.me/antlr-mega-tutorial/).
* There is also [the documentation](https://github.com/antlr/antlr4/blob/master/doc/index.md).
* The [ANTLR4 Runtime API](https://www.antlr.org/api/Java/index.html) can be helpful in understanding what you can do with the [context object](https://www.antlr.org/api/Java/org/antlr/v4/runtime/ParserRuleContext.html). Remember that you can [label alternatives](https://github.com/antlr/antlr4/blob/master/doc/parser-rules.md#alternative-labels) in your grammar to get more specific enter/exit/visit events.
* [This blogpost](https://saumitra.me/blog/antlr4-visitor-vs-listener-pattern/) might help you to decide between the listener and the visitor pattern.

### Nim
* If you're new to Nim, [Nim basics](https://narimiran.github.io/nim-basics/) is a great beginners' tutorial.
* The [official tutorial](https://nim-lang.org/docs/tut1.html) has extensions that explain [OOP](https://nim-lang.org/docs/tut2.html#object-oriented-programming), [templates](https://nim-lang.org/docs/tut2.html#templates) and [macros](https://nim-lang.org/docs/tut3.html).
* There is documentation for the [jsffi](https://nim-lang.org/docs/jsffi.html) and [macros](https://nim-lang.org/docs/macros.html) packages.
* Metaprogramming in Nim consists of constructing an AST, which you can then execute or output as Nim code. You will probably want to work with the `dumpTree` and `dumpAstGen` macros to construct code that correctly builds your AST, and the `repr` proc to check it. Here are a few examples:
	* [Building a brainfuck interpreter and compiler](https://howistart.org/posts/nim/1/) (very helpful)
	* [Nim by Example](https://nim-by-example.github.io/macros/)
	* [Introduction to Metaprogramming in Nim](https://hookrace.net/blog/introduction-to-metaprogramming-in-nim/)
	* [Demystification of Macros in Nim](https://dev.to/beef331/demystification-of-macros-in-nim-13n8)




## Credits

The code to export a symbol to JS is taken from an answer on [Stack Overflow](https://stackoverflow.com/a/62728515).

